# Изчисление на числото Pi по метода на Рамануджан
 
## Условие на задачата
Числото Pi може да бъде изчислено по различни начини, между които е намирането му чрез  сходящи редове. Един такъв бързо сходящ ред  е открит от индийският математик Сриваса Рамануджан :

![0](https://user-images.githubusercontent.com/89635038/131673611-b240f214-50c9-4250-b645-ef080873faf3.png)

Задачата е да се напише програма, пресмятаща Pi по тази формула със зададено от потребителя число n, която използва паралелни процеси.<br>
Изискванията са:
1. Команден параметър да задава точността :  “-p 1000”
2. Команден параметър задава броя нишки : “-t 5”
3. Програмата да извежда подходящи съобщения за режима си на работа, които биват :
```
     Process has started
 (1) Thread <num> has started
 (1) Thread <num> has ended 
 (1) Thread <num> execution time was …
 (2) Nonparallel execution time for current run was …
     Process has ended
     Total execution time for current run was …
```
*(  Редовете **(1)** няма да бъдат изведени ако искаме „тих“ режим на работа с команден параметър  “-q” ,<br>
докато ред  **(2)** ще бъде изведен единствено ако използваме команден параметър “-d” с цел да засечем <br>
колко време сме в непаралелна обработка за използване в закона на Амдал. )*<br>

4. Записване на резултата във изходен файл (по подразбиране result.txt) зададен чрез команден параметър “-o filename.txt” .
Като добавка е командният параметър “-g <number>” даващ възможност за контролиране на грануларността (типът на разпределение на работата между нишките)

## Описание на реализацията
За многонишково изпълнение на задачата използвам разпределение по данни за пресмятане сумата от формулата. <br>
 
Всяка нишка получава да изчисли сумата на част от елементите на редицата, като тази част бива определена от главната програма спрямо подадените параметри. След приключване на нишките главната програма събира резултатите и извършва последните изчисления за намиране на Pi и го записва в указания файл.<br>
 
Интерес представлява точно разпределението на елементите между нишките, поради наличието на факториелите във формулата.<br>
 
От една страна изчислението им ще е най ефективно , ако последователни елементи са в една нишка , но от друга разпределение от вида 1-100 в първа нишка и 901-1000 в десета нишка означава че първите нишки ще приключат работа много по бързо от последните, така намалявайки ускорението, тъй като изчакваме приключването на всички нишки.<br>
 
За да уравновеся товара използвам посоченият горе параметър g за грануларност . Например при негова стойност 2  p=1000 елемента ще бъдат разделени между t=10 нишки по следния начин: 1-50 и 501-550 в първа нишка, … , 451-500 и 951-1000 в десета нишка  като всяка от групите (на брой =g с размер (p/(t*g)) )се обработва на отделна ротация в нишките.<br> 
 
При този метод за да няма преизчисляване на вече получени в други нишки стойности въвеждаме споделена памет, във вида на масив.    Масива е с по един елемент за всяка нишка, в която тя вписва нова стойност след всеки цикъл. Така първа нишка на края на първия си цикъл е изчислила    ((-1)50(4*50)!)/((450*50!)4(882)2*50 и го записва в първа позиция на масива. През това време втората нишка може да пропусне изчисляването на тази част (вместо 54! само 51*52*53*54) и накрая да умножи полученото по стойността на първият елемент на масива и да запише резултата в втори елемент на споделения масив , за ползване от трета нишка.<br>
 
За да няма ненавременен достъп до общата памет обаче се нуждаем от синхронизация, която ще унагледим с диаграма на дейностите за две произволни нишки j и  j+1. <br>
*( Забележка ! Първа нишка  чака сигнал от последната, а на първата си ротация не чака сигнал. )*

![1](https://user-images.githubusercontent.com/89635038/131673621-c81938f7-7d28-4446-98d5-a36635385dce.png)
 
## Тестване
Проверка на резултатите ще ползваме Закон на Амдал и формулите за изчисление на ускорение и ефективност :<br>
![5](https://user-images.githubusercontent.com/89635038/131675911-76f86bad-4313-4c17-88d5-4fb573c92c7f.png)<br>
**Sp=T1/Tp**   - ускорение за р нишки <br>
**Ep=Sp/p**    - ефективност за р нишки<br>
<br> 
Първо ще тестваме обработка на *–р 1000* елемента без специално разпределяне на паметта *–g 1*<br>
 
![6](https://user-images.githubusercontent.com/89635038/131676491-29ac3a6f-3bcf-417f-8135-a215acc5bb77.png)<br>
![2](https://user-images.githubusercontent.com/89635038/131673633-cca89b47-b8f0-48d0-bc62-85b961041b31.png)
 
![3](https://user-images.githubusercontent.com/89635038/131673648-64a4185f-4333-45ff-8415-c270486f495d.png)
 
![8](https://user-images.githubusercontent.com/89635038/131676504-519e049c-20ba-4166-bc13-20c76662802b.png)<br>
![4](https://user-images.githubusercontent.com/89635038/131673653-71e4ebc5-06f6-4934-aea9-3177bd2454b0.png)
